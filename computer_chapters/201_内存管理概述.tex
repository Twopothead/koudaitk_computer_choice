\question （南京理工大学，2002年）动态重定位是在作业的（ ）中进行的
\par\twoch{编译过程}{装入过程}{链接过程}{\textcolor{red}{执行过程}}
\begin{solution}（1）静态重定位在程序装入内存的过程中完成，是指在程序开始运行前，程序中的各个地址有关的项均已完成重定位。地址变换通常是在装入时一次完成的，以后不再改变，故称为静态重定位。
（2）动态重定位不是在程序装入内存时完成的，而是CPU每次访问内存时由动态地址变换机构（硬件）自动把相对地址转换为绝对地址。动态重定位需要软件和硬件相互配合完成。
\end{solution}
\question （华中科技大学，2001年）在某系统采用基址、限长寄存器的方法来保护存储信息，判断是否越界的判断式为
\par\fourch{\textcolor{red}{0被访问的逻辑地址<限长寄存器的内容}}{0被访问的逻辑地址限长寄存器的内容}{0被访问的物理地址<限长寄存器的内容}{0被访问的物理地址限长寄存器的内容}
\begin{solution}逻辑地址的大小不能超过分配空间的大小（即限长寄存器中的内容），假设分配的空间大小为N（即寄存器内容），那么逻辑地址范围就为{[}0,N-1{]}，只有选项A满足。
还可以得到物理地址的越界判断式： 0+基址≤被访问的逻辑地址+基址
\end{solution}
\question 在虚拟内存管理中，地址变换机构将逻辑地址变为物理地址，形成该逻辑地址的阶段是（
）
\par\twoch{编辑}{编译}{\textcolor{red}{链接}}{装载}
\begin{solution}编译过后的程序需要经过链接才能装载，而链接后形成的目标程序中的地址也就是逻辑地址。以C语言为例：C语言经过预处理→编译→汇编→链接产生了可执行文件。其中链接的前一步，产生了可重定位的二进制的目标文件。C语言采用源文件独立编译的方法，如程序main.c、file.h和file.c，在链接的前一步生成了main.o和file.o，链接器将这些文件和库文件链接成一个可执行文件。链接阶段主要完成了重定位，形成逻辑的地址空间。
\end{solution}
\question 系统为某进程分配了4 个页框，
该进程已访问的页号序列为2,0,2,9,3,4,2,8,2,3,8,4,5，若进程要访问的下一页的页号为7，依据LRU
算法，应淘汰页的页号是（）
\par\twoch{2}{3}{\textcolor{red}{4}}{8}
\begin{solution}LRU 算法
\end{solution}
