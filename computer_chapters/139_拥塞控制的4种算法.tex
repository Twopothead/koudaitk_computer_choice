\question 在TCP/IP中，当发送窗口增加到32时，如果发生拥塞，则拥塞窗口将会变为
\par\twoch{\textcolor{red}{1}}{16}{24}{32}
\begin{solution}发送拥塞时门限ssthresh的值会变成拥塞窗口的一半，即16，但拥塞窗口将变成1。
\end{solution}
\question 设TCP的拥塞窗口的慢启动门限值初始为8（单位为报文段），当拥塞窗口上升到12时，网络发生超时，TCP开始慢启动和拥塞避免，那么第12次传输时拥塞窗口大小为
\par\twoch{4}{\textcolor{red}{6}}{7}{8}
\begin{solution}首先，拥塞窗口的初始值为1，此时窗口大小开始按指数增长。当拥塞窗口大于慢启动门限后，停止使用慢启动算法，改用拥塞避免算法。当发生超时时，重新设置门限值为拥塞窗口的一半，然后拥塞窗口再重新设为1。所以，拥塞窗口的变化序列为：1，2，4，8，9，10，11，12，1，2，4，6，7，8，所以第12次传输时拥塞窗口大小为6。不少同学会选择8，直接从4跳到8，请记住这个误区。
\end{solution}
\question 一个TCP连接总是以1KB的最大段长发送TCP段，发送方有足够多的数据要发送。当拥塞窗口为16KB时发生了超时，如果接下来的4个RTT（往返时间）时间内的TCP段的传输都是成功的，那么当第4个RTT时间内发送的所有TCP段都得到肯定应答时，拥塞窗口的大小是（
~）
\par\twoch{7KB}{8KB}{\textcolor{red}{9KB}}{16KB}
\begin{solution}当拥塞窗口为16KB时发生了超时，慢开始门限值将变成8KB，发送窗口变为1KB。
下面逐一列出各个RTT之后的 拥塞窗口大小。
1）开始重传：此时拥塞窗口为1KB。
2）第一次RTT结束：执行慢开始算法，此时拥塞窗口为2KB。
3）第二次RTT结束：执行慢开始算法，此时拥塞窗口为4KB。
4）第三次RTT结束：执行慢开始算法，此时拥塞窗口为8KB。
5）第四次RTT结束：由于第三次RTT结束的时候拥塞窗口的大小已经和慢开始门限值相等，所以此时应该结束
使用慢开始算法，转而使用拥塞避免算法，故此时拥塞窗口为8KB+1KB=9KB。
\end{solution}
\question 主机甲和主机乙之间已建立一个TCP连接，TCP最大段长度为1000B，若主机甲的当前拥塞窗口为4000B，在主机甲向主机乙连续发送2个最大段后，成功收到主机乙发送的对第一个段的确认段，确认段中通告的接收窗口大小为2000B，则此时主机甲还可以向主机乙发送的最大字节数是（
）
\par\twoch{\textcolor{red}{1000}}{2000}{3000}{4000}
\begin{solution}由于发送窗口的上限值=Min｛接收窗口，拥塞窗口｝，于是此时发送方的发送窗口=Min｛4000，2000｝
=2000B，而主机甲向主机乙连续发送两个最大段后，只收到第一个段的确认，所以此时主机甲还可以向主机乙
发送的最大字节数为（2000-1000）B=1000B。 【总结】
TCP要求发送端维护以下两个窗口：
1）接收端窗口rwnd，接收端根据其目前接收缓存大小所许诺的最新的窗口值，反映了接收端的容量。由接收端将其放在TCP报文的首部的窗口字段通知发送端。
2）拥塞窗口cwnd，发送端根据自己估计的网络拥塞程度而设置的窗口值，反映了网络的当前容量。
发送端的发送窗口的上限值应当取接收端窗口rwnd和拥塞窗口cwnd这两个变量中较小的一个，即应按以下公式确定：
发送窗口的上限值=Min {[}rwnd，cwnd{]}。
\end{solution}
