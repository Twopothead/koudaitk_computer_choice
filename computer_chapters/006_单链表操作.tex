\question 在一个单链表中，若删除p所指结点的后继结点，则执行（ ）
\par\fourch{\textcolor{red}{p→next=p→next→next;}}{p→next=p→next;}{p=p→next→next;}{p=p→next;p→next=p→next→next;}
\begin{solution}删除p所指结点的后继结点，修改的是p所指结点（即p→next）的指针，因此排除C和D，又因为B操作无意义，可得只有A选项正确。
\end{solution}
\question （江苏大学，2006年）设一个链表最常用的操作是在末尾插入节点和删除节点，则选用（
）最节省时间
\par\twoch{\textcolor{red}{带头结点的双循环链表}}{单循环链表}{带尾指针的单循环链表}{单链表}
\begin{solution}A带头结点的双循环链表可以通过头结点的前驱直接找到尾结点，插入和删除都是O(1)，而C带尾指针的单循环链表插入是O(1)，删除就得遍历整个链表，是O(n)。
\end{solution}
\question 下列说法中，正确的是（ ）
Ⅰ．假设某有序表的长度为n，则可以在1～（n+1）的位置上插入元素
Ⅱ．在单链表中，无论是插入还是删除操作，都必须找到其前驱结点
Ⅲ．删除双链表的中间某个结点时，只需修改两个指针域
Ⅳ．将两个各有n和m个元素的有序表（递增）归并成一个有序表，仍保持其递增有序，则最少的比较次数是m+n-1
\par\twoch{仅Ⅰ、Ⅱ、Ⅲ}{Ⅰ、Ⅱ、Ⅲ、Ⅳ}{\textcolor{red}{仅Ⅱ、Ⅲ}}{仅Ⅰ、Ⅲ、Ⅳ}
\begin{solution}Ⅰ：有序表插入的时候是不能指定位置的，因为这样可能使得插入后的表不再是有序表。正确的插入思想是：先通过元素比较找到插入的位置，再在该位置上插入，故Ⅰ错误。
Ⅱ：从单链表插入和删除的语句描述中可以看出，无论是插入还是删除操作，都必须找到其前驱结点，故Ⅱ正确。
Ⅲ：删除双链表中间某个结点时，需要修改前后两个结点的各一个指针域，共计两个指针域，故Ⅲ正确。
Ⅳ：当一个较短的有序表中所有元素均小于另一个较长的有序表中所有的元素，所需比较次数最少。假如一个有序表为1、3、4，另一个有序表为5、6、7、8、12，这样只需比较3次即可，故答案应该是n和m中较小者，即min(n，m)，故Ⅳ错误。
\end{solution}
\question （北京工商大学，2001年）对于一个头指针为head的带头结点的单链表，判定该表为空表的条件是（
）
\par\twoch{head==NULL}{\textcolor{red}{head→next==NULL}}{head→next==head}{head!=NULL}
\begin{solution}带头结点的单链表，head指针指向头结点，因此该链表为空的时候，头结点的指针值为NULL，即head→next==NULL。
\end{solution}
\question （江苏大学，2005年）单链表中，增加一个头结点的目的是（ ）
\par\twoch{使单链表至少有一个结点}{标识表结点中首结点的位置}{\textcolor{red}{方便运算的实现}}{说明单链表是线性表的链式存储}
\begin{solution}有头结点后，插入元素和删除元素的算法统一了，不再需要判断是否在第一个元素之前插入和删除第一个元素。另外，不论链表是否为空，链表指针不变。
\end{solution}
