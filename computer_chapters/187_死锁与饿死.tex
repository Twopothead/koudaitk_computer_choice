\question 关于死锁和饿死的叙述中，错误的是（ ）
\par\fourch{死锁一定发生了循环等待，而饿死则不然}{被饿死的进程可能只有一个}{\textcolor{red}{饿死进程等待的是永远不会被释放的资源}}{忙时等待（处于运行或就绪状态）的进程并非处于等待状态，但却可能被饿死；}
\begin{solution}死锁一定发生了循环等待，而饿死则不然。这也表明通过资源分配图可以检测死锁存在与否，但却不能检测是否有进程饿死，故选项A正确；死锁一定涉及多个进程，而饥饿或被饿死的进程可能只有一个，故B正确；
死锁进程等待的是永远不会被释放的资源；而饿死进程等待的是会被释放但却不会分配给自己的资源，表现为等待时间没有上界（排队等待或忙时等待），故C错误；从进程状态考虑，死锁进程都处于等待状态；忙时等待（处于运行或就绪状态）的进程并非处于等待状态，但却可能被饿死，故D正确。
\end{solution}
\question 进行p0和p1的共享变量定义及其初值为： boolean flag{[}2{]}; int turn=0;
flag{[}0{]}=FALSE; flag{[}1{]}=FALSE;
若进行p0和p1访问临界资源的类C代码实现如下： void p0() //进程p0 \{ while
(TRUE) \{ flag{[}0{]}=TRUE; turn=1; While (flag{[}1{]}\&\&(turn==1));
临界区; flag{[}0{]}=FALSE; \} \} void p1() //进程p1 \{ while (TRUE) \{
flag{[}1{]}=TRUE; turn=0; While (flag{[}0{]}\&\&(turn==0)); 临界区;
flag{[}1{]}=FALSE; \} \} 则并发执行进程p0和p1时产生的情形是（ ）
\par\fourch{不能保证进程互斥进入临界区，会出现“饥饿”现象}{不能保证进程互斥进入临界区，不会出现“饥饿”现象}{能保证进程互斥进入临界区，会出现“饥饿”现象}{\textcolor{red}{能保证进程互斥进入临界区，不会出现“饥饿”现象}}
\begin{solution}在之前没有了解过该算法的情况下，临场想要判断出来还是比较困难的，尤其本题的算法是一个可以保证进程互斥进入临界区且不会出现饥饿现象的良好算法，在考虑的时候，没法找出破绽，还容易误认为自己的想法不够全面而耽误时间。
下面分析算法。
首先是初始化步骤。第一步是初始化两个数组元素为FALSE，表明初始状态两个进程都没有打算进入临界区。第二步是turn置为0，这里的turn置为0并没有特殊的用意，有些读者会理解为优先执行进程P0，其实仔细分析并不是。因为对于turn的赋值操作都是在对turn的判断之前，也就是在程序执行开始后，都会先对turn值进行操作，然后才会判断，这里turn=0的用意仅仅是对turn值进行一个初始化，改为turn=1的效果也是完全相同的。
其次分析每个进程的执行流程（本题解释有些烦琐，如果已经掌握本题，跳过即可。对于不熟悉本题的读者，请紧跟解析，一次看完，中途打断思路可能会跟不上）。
由于进程P0和P1的执行流程类似，所以分析进程P0即可。假设此时进程P0要访问临界资源，进程P1尚未执行，开始执行题目中的代码，首先会进入第一个while循环（while(TRUE)），循环中第一行语句为``flag{[}0{]}=TRUE;
turn=1;''，将代表自己的flag置为TRUE，并将turn置为1，表明进程P0要申请访问临界资源（flag{[}0{]}=TRUE），并表明自己访问结束之后轮到进程P1访问临界资源（turn=1）。
接下来语句为``While
(flag{[}1{]}\&\&(turn==1));''。这句是很多考生粗心看错且很难弄明白含义的一个语句，本语句有着保证避免饥饿现象和互斥访问的作用，为本题的关键所在。
首先要注意这个while循环语句的最后有一个分号，表明该语句的含义是如果满足条件则执行空语句，直到不满足条件才跳出循环执行下面的语句，即不满足条件才进入临界区。在这一点上很多考生粗心漏看了分号而误认为本句是满足条件才进入临界区。
然后分析这句为什么能保证互斥访问和避免饥饿现象。先解释为什么能保证互斥。如果进程P1正在访问临界区，则相关变量的值为flag{[}0{]}=FALSE，flag{[}1{]}=TRUE，turn=0，这时候如果进程P0请求访问临界区，则会将flag{[}0{]}赋值为TRUE，turn赋值为1，此时相关变量就变为flag{[}0{]}=TRUE，flag{[}1{]}=TRUE，turn=1，此时进程P0会由于满足while循环的条件（flag{[}1{]}\&\&(turn==1)）而不断执行空语句，直到进程P1访问完临界资源并将flag{[}1{]}置为FALSE，才能够跳出循环并进入临界区。对于进程P1情况类似，因此该算法能够保证两个进程互斥进入临界区。
接下来解释为什么能够避免饥饿现象。所谓饥饿现象是指某进程请求执行却长期得不到调度。本题中的一种饥饿现象就是进程P1提出申请，但系统却一直执行进程P0，导致进程P1长期得不到调度。分析相关变量情况。当进程P0正在临界区执行，此时进程P1提出进入临界区的请求时，执行``flag{[}1{]}=TRUE;
turn=0;''语句后，相关变量情况为flag{[}0{]}=TRUE，flag{[}1{]}=TRUE，turn=0。等待进程P0本次临界区执行结束（执行了flag{[}0{]}=FALSE;），紧接着进程P0又提出了访问请求，假设处理器总是优先执行进程P0的请求，则进程P0可以无阻碍地执行完``flag{[}0{]}=TRUE;
turn=1;''，此时相关变量情况为flag{[}0{]}=TRUE，flag{[}1{]}=TRUE，turn=1，则此时进程P0会执行语句``While
(flag{[}1{]}
\&\&(turn==1));''。这时候会由于满足条件而不断执行空语句，由于仅仅依靠进程P0已经无法跳出循环（因为此时进程P0已经没有改变，flag{[}1{]}和turn的语句可以执行），这时进程P1也是执行对应的一条语句``While
(flag{[}0{]}\&\&(turn==0));''，由于turn=1，所以进程P1会跳出这个循环并进入临界区执行，因此在假设处理器非常偏心进程P0的情况下进程P1还是会得到执行。进程P1执行完之后，也会有类似情况而使进程P0得到调度执行，所以进程P0和进程P1是交替执行的，本算法并不存在饥饿现象。
实际上，该算法为Peterson算法，满足互斥、空闲让进、有限等待3条同步机制准则，可以达到比较好的同步效果。本算法通过flag数组保证两个进程互斥进入临界区，同时通过turn来保证两个进程交替执行，避免了饥饿现象。本算法的缺点是无法设置进程的优先级，比如不能做到在进程P1提出申请后，仍然使进程P0连续执行多次，只能交替执行。但瑕不掩瑜，这仍然是一个能选出正确选项的好算法。
\end{solution}
