\question （重庆大学，2004年）若要在O(1)的时间复杂度上实现两个循环链表头尾相接，则对应两个循环链表各设置一个指针，分别指向（
）
\par\twoch{各自的头结点}{\textcolor{red}{各自的尾结点}}{各自的第一个元素结点}{一个表的头结点，另一个表的尾结点}
\begin{solution}两个循环链表头尾相接，需要改变头结点和尾结点之间的指针，而这个指针是从尾结点指向头结点的，所以只有将两个指针分别指向自己循环链表的尾结点才能完成操作。
实现的代码如下： void connect(LNode *A,LNode *\&B)
//假设A、B为非空带头结点的循环链表的尾指针 \{ LNode *p=A→next;
//保存A表的头结点 A→next=B→next→next; //B的开始结点链接到A表尾
free(B→next); //释放B表的头结点 B→next=p;
//将B表的尾结点链接到A表的头结点 \}
【小技巧】一般出现循环链表的题目时，尾指针的作用总是大于头指针的，因为头指针可通过尾指针直接得到。因此这样的题目一般都会选择带尾指针的选项。
\end{solution}
\question （南开大学，2005年）在一个链队列中，假设f和r分别为队首和队尾指针，则插入s所指结点的运算是（
）
\par\twoch{f→next=s;f=s;}{\textcolor{red}{r→next=s;r=s;}}{s→next=r;r=s;}{s→next=f;f=s;}
\begin{solution}插入是在队尾进行的，即在r所指结点之后插入结点s，因此正确的操作为B。
\end{solution}
\question （广东工业大学，2002年）在链队列的出队操作中，修改尾指针的情况发生在（
）
\par\twoch{\textcolor{red}{变成空队列的时候}}{变成满队列的时候}{队列只剩下一个元素的时候}{任何时候}
\begin{solution}出队一般只修改头指针，但如果头指针和尾指针指向同一个结点，且需要进行出队操作时，那么就需要修改尾指针，因此本题选A。
\end{solution}
\question 下列关于链式栈的叙述中，错误的是（ ~）。

~Ⅰ．链式栈只能顺序存取，而顺序栈不但能顺序存取，还能直接存取
Ⅱ．因为链式栈没有栈满问题，所以进行进栈操作，不需要判断任何条件

~Ⅲ．在链式队列的出队操作中，需要修改尾指针的情况发生在空队列的时候
\par\twoch{仅Ⅰ}{仅Ⅰ、Ⅱ}{仅Ⅱ}{\textcolor{red}{Ⅰ、Ⅱ、Ⅲ}}
\begin{solution}Ⅰ：栈要求只能在表的一端（栈顶）访问、插入和删除，这决定了栈无论采用何种存储方法表示，只能顺序访问，不能直接存取，故Ⅰ错误。

~Ⅱ：每创建新的栈结点时还要判断是否动态分配成功，若不成功，则进栈操作失败。
StackNode *s=new StackNode; if(s==NULL)\{ ~
~printf(``结点存储分配失败！\textbackslash{}n'')； \} 故Ⅱ错误。

~Ⅲ：首先要清楚链式队列需要两个指针，即头指针和尾指针。当链队列需要插入元素时，在链式队列尾部插入一个新的结点，并且修改尾指针；当链队列需要删除元素时，在链式队列头部删除一个结点，并且修改头指针。所以当链式队列需要进行入队操作时，应该只需修改尾指针即可。但是有一种特殊情况（考生务必记住，因为不少考生在写链式队列出队的算法时，并没有考虑到去判断这种情况），就是当此时只有一个元素时，不妨设此时链式队列有头结点，那么当唯一一个元素出队时，应该将头指针指向头结点，并且此时尾指针也是指向该唯一的元素，所以此时需要修改尾指针，并且使尾指针指向头结点，故Ⅲ错误。
\end{solution}
