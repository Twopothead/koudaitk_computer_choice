\question （南开大学，2000年）下列排序算法中，（
）算法可能会出现``在最后一趟开始之前，所有元素都不在其最终位置上''的情况
\par\twoch{堆排序}{冒泡排序}{快速排序}{\textcolor{red}{插入排序}}
\begin{solution}经过一趟排序，能够保证一个元素到达最终位置的，这样的排序是交换类的两种（冒泡、快速）和选择类的两种（简单选择和堆），因此排除A、B和C。
\end{solution}
\question （武汉大学，2005年）设线性表中每个元素有两个数据项K1和K2，现对线性表按下列规则进行排序：先看数据项K1，K1值小的在前，大的在后；在K1值相同的情况下，再看数据项K2，K2值小的在前，大的在后。满足这种要求的排序方法是（
）
\par\fourch{先按K1值进行直接插入排序，再按K2值进行简单选择排序}{先按K2值进行直接插入排序，再按K1值进行简单选择排序}{先按K1值进行简单选择排序，再按K2值进行直接插入排序}{\textcolor{red}{先按K2值进行简单选择排序，再按K1值进行直接插入排序}}
\begin{solution}若先按K1值排序后，再按K2值排序，那么就会打乱原先K1值的次序，这不符合题目中K1优先的要求，因此排除A和C。
因此需要先进行K2的排序，在K1值相等的情况下，要保持原来K2值的次序，即要求进行K1值排序的算法是稳定的，由于直接插入排序是稳定的，简单选择排序是不稳定的，因此应该先按K2值进行简单选择排序，再按K1值进行直接插入排序。
\end{solution}
\question 对同一待排序序列分别进行折半插入排序和直接插入排序，两者之间可能的不同之处是（
）
\par\twoch{排序的总趟数}{元素的移动次数}{使用辅助空间的数量}{\textcolor{red}{元素之间的比较次数}}
\begin{solution}折半插入排序和直接插入排序相比主要是在有序区采用折半查找插入元素位置，当排序元素个数较多时会减少元素之间的比较次数，但不会减少元素的移动次数，也不会减少排序的总趟数。
【总结】如果考生一时想不出，也可以用简单的排序例子来进行解答。
\end{solution}
\question （西南交通大学，2005年）下列排序算法中，某一趟排序结束后未必能选出一个元素放在其最终位置上的是（
）
\par\twoch{堆排序}{冒泡排序}{\textcolor{red}{直接插入排序}}{快速排序}
\begin{solution}堆排序、冒泡排序每趟都会选出一个最大或最小的放到其最终的位置，快速排序每一趟都会令其原序列的第一个元素放到其最终位置
\end{solution}
\question （南京邮电大学，2006年）采用直接插入排序方法对下面所列出的4个序列进行排序（由小到大）。使得直接插入排序时间最长的序列是（
）
\par\fourch{10,20,30,40,50,60,70}{\textcolor{red}{70,60,50,40,30,20,10}}{40,10,30,20,60,50,70}{40,20,10,30,50,70,60}
\begin{solution}当数据逆序时，直接插入排序的时间最长
\end{solution}
