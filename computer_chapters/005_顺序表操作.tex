\question （南京林业大学，2004年）对于顺序存储的线性表，设其长度为n，在任何位置上插入或删除操作都是等概率的。插入一个元素时大约要移动表中的（
）个元素
\par\twoch{\textcolor{red}{n/2}}{(n+1)/2}{(n-1)/2}{n}
\begin{solution}总共有n+1个插入位置，分别需要移动元素的个数为n,n-1,n-2,\ldots{}.1,0，又因为是等概率的，所以平均需要移动n(n+1)/2(n+1)=n/2.
\end{solution}
\question 在顺序表的动态存储定义中需要包含的数据成员是（ ~）。~

\ding{192}．数组指针*data

~\ding{193}．表中元素个数n~

\ding{194}．表的大小maxSize

~\ding{195}．数组基址base
\par\twoch{\ding{192}、\ding{193}}{\ding{192}、\ding{193}、\ding{195}}{\textcolor{red}{\ding{192}、\ding{193}、\ding{194}}}{全都需要}
\begin{solution}首先，表的大小和表的元素个数是肯定需要的。其次，在顺序表的动态存储定义中，它的存储空间是通过执行malloc或new动态分配的，所以不包括数组基址。最后，数组的首地址需要数组指针data来存储。
\end{solution}
\question 下列说法中，正确的是（ ）
\ding{192}．假设某有序表的长度为n，则可以在1～（n+1）的位置上插入元素
\ding{193}．在单链表中，无论是插入还是删除操作，都必须找到其前驱结点
\ding{194}．删除双链表的中间某个结点时，只需修改两个指针域
\ding{195}．将两个各有n和m个元素的有序表（递增）归并成一个有序表，仍保持其递增有序，则最少的比较次数是m+n-1
\par\twoch{仅\ding{192}、\ding{193}、\ding{194}}{\ding{192}、\ding{193}、\ding{194}、\ding{195}}{\textcolor{red}{仅\ding{193}、\ding{194}}}{仅\ding{192}、\ding{194}、\ding{195}}
\begin{solution}\ding{192}：有序表插入的时候是不能指定位置的，因为这样可能使得插入后的表不再是有序表。正确的插入思想是：先通过元素比较找到插入的位置，再在该位置上插入，故\ding{192}错误。
\ding{193}：从单链表插入和删除的语句描述中可以看出，无论是插入还是删除操作，都必须找到其前驱结点，故\ding{193}正确。
\ding{194}：删除双链表中间某个结点时，需要修改前后两个结点的各一个指针域，共计两个指针域，故\ding{194}正确。
\ding{195}：当一个较短的有序表中所有元素均小于另一个较长的有序表中所有的元素，所需比较次数最少。假如一个有序表为1、3、4，另一个有序表为5、6、7、8、12，这样只需比较3次即可，故答案应该是n和m中较小者，即min(n，m)，故\ding{195}错误。
\end{solution}
\question （哈尔滨工业大学，2004年）在n个结点的线性表的数组实现中，算法的时间复杂度是O(1)的操作是（
）
\par\fourch{\textcolor{red}{访问第i个结点（1≤i≤n）和求第i个结点的直接前驱（2≤i≤n）}}{在第i个结点后插入一个新结点（1≤i≤n）}{删除第i个结点（1≤i≤n）}{以上都不对}
\begin{solution}顺序存储的线性表，线性表中的任一数据元素都可随机存取，时间复杂度为O(1)。
而顺序表的增加、删除结点的时间复杂度为O(n)。
\end{solution}
\question （哈尔滨工业大学，2001年）若某线性表最常用的操作是存取任一指定序号的元素和在最后进行插入和删除运算，则利用（
）存储方式最节省时间
\par\twoch{\textcolor{red}{顺序表}}{双链表}{带头结点的双循环链表}{单循环链表}
\begin{solution}线性表的顺序存储结构是一种随机存取的存储结构，因此用顺序表最节省时间。
\end{solution}
\question （北京理工大学，2004年）若线性表最常用的操作是存取第i个元素及其前驱和后继元素的值，为节省时间应采用的存储方式为（
）
\par\twoch{单链表}{双向链表}{单循环链表}{\textcolor{red}{顺序表}}
\begin{solution}线性表的顺序存储结构是一种随机存取的存储结构，因此用顺序表最节省时间。
\end{solution}
