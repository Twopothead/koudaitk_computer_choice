\question （南京理工大学，2002年）动态重定位是在作业的（ ）中进行的
\par\twoch{编译过程}{装入过程}{链接过程}{\textcolor{red}{执行过程}}
\begin{solution}（1）静态重定位在程序装入内存的过程中完成，是指在程序开始运行前，程序中的各个地址有关的项均已完成重定位。地址变换通常是在装入时一次完成的，以后不再改变，故称为静态重定位。
（2）动态重定位不是在程序装入内存时完成的，而是CPU每次访问内存时由动态地址变换机构（硬件）自动把相对地址转换为绝对地址。动态重定位需要软件和硬件相互配合完成。
\end{solution}
\question 下列存储管理方案中，可以采用静态重定位的是
\par\twoch{\textcolor{red}{固定分区管理方案}}{可变分区管理方案}{页式管理方案}{段式管理方案}
\begin{solution}在固定分区方式中，作业分区情况一旦确定便不会改变，故可以采用静态重定位。其余三种管理方案均可能在运行过程中改变作业分区情况，故不可以采用静态重定位。
\end{solution}
\question （武汉理工大学，2005年）下面的存储管理方案中，（
）方式可以采用静态重定位
\par\twoch{\textcolor{red}{固定分区}}{可变分区}{页式}{段式}
\begin{solution}静态重定位在程序装入内存的过程中完成，是指在程序开始运行前，程序中的各个地址有关的项均已完成重定位。地址变换通常是在装入时一次完成的，以后不再改变。
只有在固定分区方式中，作业分区情况一旦确定便不会改变，故可以采用静态重定位。其余3种管理方案均可能在运行过程中改变作业分区情况，故不可以采用静态重定位。
\end{solution}
\question 采用可重入程序是通过（ ）方法来改善系统性能的
\par\twoch{改变时间片长度}{改变用户数}{提高对换速度}{\textcolor{red}{减少对换数量}}
\begin{solution}可重入程序主要是通过共享来使用同一块存储空间的，或者通过动态链接的方式将所需的程序段映射到相关进程中，最大的优点就是减少了对程序段的调入调出，因此减少了对换数量。
\end{solution}
\question 程序的装入方式中，目标程序可以不经过任何改动而装入物理内存单元的是
\par\twoch{静态重定位}{\textcolor{red}{动态重定位}}{编译或汇编}{存储扩充}
\begin{solution}动态重定位允许程序运行时在内存中移动位置，把装入模块装入到内存后的所有地址都是相对地址。在程序执行过程中，每当访问到相应指令或数据时，才将要访问的程序或数据的相对地址转换为物理地址，所以说动态重定位适合将目标程序直接装入内存。
\end{solution}
\question 对重定位存储管理方式，应
\par\fourch{\textcolor{red}{在整个系统中设置一个重定位寄存器}}{为每道程序设置一个重定位寄存器}{为每道程序设置两个重定位寄存器}{为每道程序和数据都设置一个重定位寄存器}
\begin{solution}为使地址转换不影响到指令的执行速度，必须有硬件地址变换结构的支持，即需在系统中增设一个重定位寄存器，用它来存放程序（数据）在内存中的起始地址。在执行程序或访问数据时，真正访问的内存地址是相对地址与重定位寄存器中的地址相加而成的，这时将起始地址存入重定位寄存器，之后的地址访问即可通过硬件变换实现。因为系统处理器在同一时刻只能执行一条指令或访问数据，所以为每道程序（数据）设置一个寄存器是没有必要的（同时也不现实，因为寄存器是很昂贵的部件，而且程序的道数也无法估计），而只需在切换程序执行时重置寄存器内容即可。
\end{solution}
\question 考虑使用大小相等分区的固定分区方案。分区大小为2\^{}16B，主存的大小为2\^{}24B。使用一个进程表来包含每一个进程对应的分区。那么，进程表中指向这些分区的指针需要的位数为
\par\twoch{24}{16}{\textcolor{red}{8}}{40}
\begin{solution}分区数目等于主存的字节数除以每个分区的字节数：2\^{}24/2\^{}16=2\^{}8，每8位二进制数表示2\^{}8个分区中的一个分区。
\end{solution}
\question 在运行过程中，许多系统允许程序分配更多的内存给它的地址空间。在程序堆中的数据分配是这种分配方式的一个实例。下列关于不同内存分配方式的说法错误的是
\par\fourch{连续内存分配方式下，当没有足够的空间给程序去扩大它已分配的内存空间时，将要求重新分配整个程序}{纯段式分配方式下，当没有足够的空间给段去扩大它的已分配内存空间时，将要求重新分配整个段}{\textcolor{red}{纯页式分配方式下，当需要扩大它的已分配内存空间时，将要求重新分配全部页}}{在段页式分配方式下，当需要扩大它的已分配内存空间时，系统不需要重新分配全部页}
\begin{solution}其实只要知道每种分配方式最小的内存单位（需要连续地址空间的最小块）是什么，答案就容易得出来了。连续内存分配方式下，最小的内存单位就是整个程序。当没有足够的空间去扩大已分配内存时，就需要重新分配整个程序。纯段式分配方式下，最小的内存单位就是段，当没有足够的空间去扩大已分配给段的内存时，就需要重新分配整个段。故A选项和B选项都是正确的。
纯页式分配方式下，它的内存单位（页）大小是不可变的，故不可能会有重新分配全部页的情况。C选项中提到的情况，只需要添加页表项即可，即增加新分配的页给程序的地址空间，故C选项错误。
段页式管理方式对于内存空间的分配也都是以页为单位的，所以不需要重新分配全部页，只要对每个段对应的页表添加页表项即可，故D选项正确。
\end{solution}
\question 在动态分区式内存管理中，能使内存空间中空闲区分布较均匀的算法是
\par\twoch{最佳适应算法}{最坏适应算法}{首次适应算法}{\textcolor{red}{循环首次适应算法}}
\begin{solution}循环首次适应算法是由首次适应算法演变而成的。在为进程分配内存空间时，不再是每次都从链首开始查找，而是从上次找到的空闲分区的下一个空闲分区开始查找，直至找到一个能满足要求的空闲分区，从中划出一块与请求大小相等的内存空间分配给作业。该算法能使内存中的空闲分区分布得更均匀，从而减少了查找空闲分区时的开销，但这样会缺乏大的空闲分区。
\end{solution}
\question 在存储管理方案中，可用上、下限地址寄存器存储保护的是
\par\twoch{页式管理}{段式管理}{\textcolor{red}{固定分区管理}}{段页式管理}
\begin{solution}固定分区管理可采用静态重定位的方式装入作业。装入程序把作业中的逻辑地址转换为绝对地址，并检查绝对地址是否在指定（装入）的分区内，如果是，就装入这个作业；否则就不能装入。如果装入主存分区的作业占用处理器时（注意，是运行时），进程调度程序（不是装入程序了）必须把作业所在分区的上下限地址存入``下限寄存器''和``上限寄存器''中，这样可以在指令执行中判断其所用到的绝对地址是否越界，达到存储保护的目的。
其他选项的管理方式对于存储保护都是通过其他寄存器（或方式）来进行内存保护的。考生可自己总结。
\end{solution}
\question 在动态分区式内存管理中，首次适应算法的空闲区是
\par\twoch{\textcolor{red}{按地址递增顺序连在一起}}{始端指针表指向最大空闲区}{按大小递增顺序连在一起}{寻找从最大空闲区开始}
\begin{solution}以空闲分区链为例来说明采用首次适应算法（FF）时的分配情况。FF算法要求空闲分区链以地址递增的次序链接。在分配内存时，从链首开始顺序查找，直至找到一个大小能满足要求的空闲分区为止；然后再按照作业的大小，从该分区中划出一块内存空间分配给请求者，余下的空闲分区仍留在空闲链中。若从链首直至链尾都不能找到一个能满足要求的分区，则此次内存分配失败，返回。
\end{solution}
\question 支持程序存放在不连续内存中的存储管理方法有（ ）。 Ⅰ．动态分区分配
Ⅱ．固定分区分配 Ⅲ．分页式分配 Ⅳ．段页式分配 Ⅴ．分段式分配
\par\twoch{Ⅰ和Ⅱ}{Ⅲ和Ⅳ}{\textcolor{red}{Ⅲ、Ⅳ和Ⅴ}}{Ⅱ、Ⅳ和Ⅴ}
\begin{solution}非连续分配允许一个程序分散地装入不相邻的内存分区中。动态分区分配和固定分区分配都属于连续分配方式，而非连续分配有分页式分配、分段式分配和段页式分配三种。
\end{solution}
\question 若用8个字（字长32位，且字号从0开始计数）组成的位示图管理内存，用户归还一个块号为100的内存块时，它对应位示图的位置为（
）（注意：位号也从0开始）
\par\twoch{字号为3，位号为5}{字号为4，位号为4}{\textcolor{red}{字号为3，位号为4}}{字号为4，位号为5}
\begin{solution}本题考查位示图的基本计算。首先求出块号为100在哪一个字号，0～31在字号0，32～63在字号1，64～95在字号2，96～127在字号3，所以块号100在字号3。之后需要解决的问题就是求出第100块在字号3的哪一位，字号3的第0位是第96块，依次类推，第100块在字号3的第4位。
\end{solution}
\question 采用（ ）不会产生内部碎片
\par\twoch{分页式存储管理}{\textcolor{red}{分段式存储管理}}{固定分区式存储管理}{段页式存储管理}
\begin{solution}分段式存储管理以段为单位分配一片连续的内存空间，其内存分配和回收类似于动态分区存储管理，用多少分配多少，因此不存在内部碎片。而分页、段页式和分区式都会产生内部碎片。
\end{solution}
\question 下面哪种内存管理方法有利于程序的动态链接
\par\twoch{\textcolor{red}{分段存储管理}}{分页存储管理}{可变式存储管理}{固定式存储管理}
\begin{solution}动态链接是指在作业运行之前，并不把几个目标程序段链接起来。要运行时，先将主程序所对应的目标程序装入内存并启动运行，当运行过程中又需要调用某段程序时，才将该段（目标程序）调入内存并进行链接。可见，动态链接也要求以段作为管理的单位。
\end{solution}
\question 在现代计算机系统中，存储器是十分重要的资源，能否合理有效地使用存储器在很大程度上反映了操作系统的性能，并直接影响到整个计算机系统作用的发挥。可以通过哪些途径来提高主存利用率（
）。 Ⅰ．将连续分配方式改为离散分配方式 Ⅱ．增加对换机制
Ⅲ．引入虚拟存储机制 Ⅳ．引入存储器共享机制
\par\twoch{Ⅰ、Ⅱ和Ⅲ}{Ⅰ、Ⅱ和Ⅳ}{Ⅱ、Ⅲ和Ⅳ}{\textcolor{red}{全是}}
\begin{solution}Ⅰ对，将连续分配方式改为离散分配方式以减少内存的零头。
Ⅱ对，增加对换机制，将那些暂时不能运行的进程或暂不需要的程序或数据换出至外存，以腾出内存来装入运行的程序。
Ⅲ对，引入虚拟存储机制，使更多的作业能够装入内存，提高CPU和内存利用率。
引入动态链接机制，当程序在运行中需要调用某段程序时才将该程序装入内存，从而避免装入不会用到的程序段和数据。
Ⅳ对，引入存储器共享机制，允许一个正文段或数据段被若干程序共享以消除内存中的重复拷贝现象。
\end{solution}
\question （西安电子科技大学，2007年）不会产生内部碎片的存储管理是
\par\twoch{分页式存储管理}{\textcolor{red}{分段式存储管理}}{固定分区式存储管理}{段页式存储管理}
\begin{solution}只要是固定大小的分配就会产生内部碎片，其余的都会产生外部碎片。如果固定和不固定同时存在（如段页式），物理本质还是固定的，解释如下。
分段虚拟存储管理：每一段的长度都不一样（对应不固定），所以会产生外部碎片，但不会产生内部碎片。
分页虚拟存储管理：每一页的长度都一样（对应固定），所以会产生内部碎片，但不会产生外部碎片。
段页式分区管理：地址空间首先被分成若干个逻辑分段（这里的分段只是逻辑上的，而我们所说的碎片都是物理上真实存在的，是否有碎片还是要看每个段的存储方式，所以页才是物理单位），每段都有自己的段号，然后再将每个段分成若干个固定的页。所以其仍然是固定分配，会产生内部碎片。
固定式分区管理：很明显是固定的大小，会产生内部碎片。 综上分析，本题选B。
\end{solution}
\question 以下存储管理方式中，会产生内部碎片的是（ ）。 Ⅰ．请求分段存储管理
Ⅱ．请求分页存储管理 Ⅲ．段页式分区管理 Ⅳ．固定式分区管理
\par\twoch{Ⅰ、Ⅱ、Ⅲ}{Ⅲ、Ⅳ}{只有Ⅱ}{\textcolor{red}{Ⅱ、Ⅲ、Ⅳ}}
\begin{solution}只要是固定的分配就会产生内部碎片，其余的都产生外部碎片。如果固定和不固定同时存在（例如段页式），则看做固定。请求分段：每段的长度不同（不固定），产生外部碎片。请求分页：每页大小固定，产生内部碎片。段页式：视为固定，产生内部碎片。固定式分区管理产生的是内部碎片。
\end{solution}
\question （西安电子科技大学，2007年）在空白表中，空白区按其长度由小到大进行查找的算法称为（
）算法
\par\twoch{\textcolor{red}{最佳适应}}{最差适应}{最先适应}{先进先出}
\begin{solution}所谓最佳是指每次为作业分配内存时，总是把能满足要求、又是最小的空闲分区分配给作业，避免``大材小用''。为了加速寻找，该算法要求将所有的空闲分区按其容量以从小到大的顺序形成一空闲分区链。这样，第一次找到的能满足要求的空闲区必然是最佳的。
\end{solution}
\question 释放和合并空闲内存页时，采用下列哪种管理方式速度最快
\par\twoch{\textcolor{red}{空闲页位图}}{空闲页栈}{空闲页链表}{空闲表}
\begin{solution}在位图上很容易判断释放页的上邻和下邻页是否空闲，故合并空闲内存页时只要经过两步或数步的判断。栈和链表都需要遍历才能找到释放页的上邻和下邻页。空闲表也是需要遍历一遍表才能确定释放页的上邻和下邻是否空闲。综上，采用位图管理空闲内存页，在释放和合并空闲内存页时速度是最快的。
\end{solution}
