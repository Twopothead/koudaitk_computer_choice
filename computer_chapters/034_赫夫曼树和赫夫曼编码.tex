\question 对n（n≥2）个权值均不相同的字符构成赫夫曼树。下列关于该赫夫曼树的叙述中，错误的是（
）
\par\twoch{\textcolor{red}{该树一定是一棵完全二叉树}}{树中一定没有度为1的结点}{树中两个权值最小的结点一定是兄弟结点}{树中任一非叶结点的权值一定不小于下一层任一结点的权值}
\begin{solution}赫夫曼树为带权路径长度最小的二叉树，不一定是完全二叉树，故A错误。
赫夫曼树中没有度为１的结点，B正确。
构造赫夫曼树时，最先选取两个权值最小的结点作为左右子树构造一棵新的二叉树，C正确。
从赫夫曼树的构造过程，从森林中选取两棵根结点的权值最小的子树分别作为左、右子树构造一棵新的二叉树T。首先新二叉树T的根结点的权值必然大于其自己左、右子树根结点的权值，因为它等于左、右子树根结点值之和。
我们还需要考虑的是，新二叉树T根结点的兄弟结点N的权值是否大于T的左、右子树根结点的权值。若N的权值小于T左、右子树根结点的权值，则在构造T时，T的左、右子树根结点的权值不是最小的，这则与T1的赫夫曼树构造过程相矛盾。综上，赫夫曼树中任一非叶结点的权值一定不小于下一层任一结点的权值，故D正确。
【总结】
假设有n个权值，则构造出的赫夫曼树有n个叶子结点。n个权值分别设为w1、w2、\ldots{}、wn，则赫夫曼树的构造规则为：
（1）将w1、w2、\ldots{}，wn看成是有n棵树的森林（每棵树仅有一个结点）；
（2）在森林中选出两个根结点的权值最小的树合并，作为一棵新树的左、右子树，且新树的根结点权值为其左、右子树根结点权值之和；
（3）从森林中删除选取的两棵树，并将新树加入森林；
（4）重复（2）、（3）步，直到森林中只剩一棵树为止，该树即为所求得的赫夫曼树。
\end{solution}
\question （哈尔滨工程大学，2005年）设哈弗曼编码的长度不超过4，若已对两个字符编码为1和01，则还可以对（
）个字符编码
\par\twoch{2}{3}{\textcolor{red}{4}}{5}
\begin{solution}根据前缀编码的规则，剩下的字符编码不能有1和01的前缀，则剩余的只能以00开头，又因为长度不超过4，故剩余的两位一共有四种情况0000、0001、0010、0011
\end{solution}
